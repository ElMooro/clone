import os
import json
import asyncio
from fastapi import FastAPI, HTTPException, Query
from fastapi.middleware.cors import CORSMiddleware
from typing import Optional, List
import uvicorn
from datetime import datetime, timedelta
import pandas as pd
import numpy as np
from scipy import stats

# Set up environment variables in the expected format
env_mapping = {
    "OPENBB_API_FRED_KEY": os.getenv("OPENBB_FRED_KEY"),
    "OPENBB_API_FMP_KEY": os.getenv("OPENBB_FMP_KEY"),
    "OPENBB_API_POLYGON_KEY": os.getenv("OPENBB_POLYGON_KEY"),
    "OPENBB_API_BLS_KEY": os.getenv("OPENBB_BLS_KEY"),
    "OPENBB_API_BENZINGA_KEY": os.getenv("OPENBB_BENZINGA_KEY"),
    "OPENBB_API_TIINGO_KEY": os.getenv("OPENBB_TIINGO_KEY"),
    "OPENBB_API_EIA_KEY": os.getenv("OPENBB_EIA_KEY"),
    "OPENBB_API_BEA_KEY": os.getenv("OPENBB_BEA_KEY"),
    "OPENBB_API_CENSUS_KEY": os.getenv("OPENBB_CENSUS_KEY"),
    "OPENBB_API_ECONDB_KEY": os.getenv("OPENBB_ECONDB_KEY"),
    "OPENBB_API_NASDAQ_KEY": os.getenv("OPENBB_NASDAQ_KEY"),
}

# Update environment
for key, value in env_mapping.items():
    if value:
        os.environ[key] = value

# Create user settings
user_settings = {
    "credentials": {}
}

for key, value in env_mapping.items():
    if value and key.startswith("OPENBB_API_"):
        provider_key = key.replace("OPENBB_API_", "").replace("_KEY", "").lower()
        user_settings["credentials"][provider_key] = value

# Write settings file
with open("/app/.openbb_platform/user_settings.json", "w") as f:
    json.dump(user_settings, f)

# Import OpenBB after setting up credentials
from openbb import obb

app = FastAPI(title="OpenBB Platform API")

# Configure CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

def process_response(response):
    """Process OpenBB response into consistent format."""
    if hasattr(response, 'to_dict'):
        return response.to_dict()
    elif hasattr(response, 'results'):
        if isinstance(response.results, list):
            return {"data": response.results}
        elif hasattr(response.results, 'to_dict'):
            return response.results.to_dict()
        else:
            return {"data": response.results}
    elif isinstance(response, dict):
        return response
    else:
        return {"data": str(response)}

# Root endpoint
@app.get("/")
async def root():
    return {"message": "OpenBB Platform API", "status": "operational"}

# Providers endpoint
@app.get("/api/v1/universal/providers")
async def get_providers():
    return {"providers": ["fred", "fmp", "polygon", "bls", "benzinga", "tiingo"]}

# Economy endpoints
@app.get("/api/v1/economy/fred_series")
async def fred_series(symbol: str, provider: str = "fred"):
    try:
        response = await obb.economy.fred_series(symbol=symbol, provider=provider)
        return process_response(response)
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/v1/economy/unemployment")
async def unemployment(provider: str = "bls"):
    try:
        response = await obb.economy.unemployment(provider=provider)
        return process_response(response)
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# Equity endpoints
@app.get("/api/v1/equity/price/quote")
async def equity_quote(symbol: str, provider: str = "fmp"):
    try:
        response = await obb.equity.price.quote(symbol=symbol, provider=provider)
        return process_response(response)
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# Universal data endpoint - Enhanced to handle multiple providers
@app.get("/api/v1/universal/data")
async def universal_data(
    symbol: str,
    provider: str = "fred",
    start_date: Optional[str] = None,
    end_date: Optional[str] = None,
    limit: Optional[int] = None
):
    try:
        kwargs = {"symbol": symbol, "provider": provider}
        if start_date:
            kwargs["start_date"] = start_date
        if end_date:
            kwargs["end_date"] = end_date
        if limit:
            kwargs["limit"] = limit
        
        # Route to appropriate endpoint based on provider
        if provider == "ecb":
            # ECB data through OpenBB
            response = await obb.economy.european_central_bank_interest_rates(**kwargs)
        elif provider == "newyorkfed":
            # NY Fed data through OpenBB
            if symbol in ["SOFR", "EFFR", "OBFR", "TGCR", "BGCR"]:
                response = await obb.fixedincome.rate.sofr(**kwargs)
            else:
                response = await obb.economy.fred_series(**kwargs)
        elif provider == "ofr":
            # OFR data through OpenBB
            response = await obb.economy.fred_series(**kwargs)
        elif provider == "treasury":
            # Treasury data through OpenBB
            response = await obb.fixedincome.government.treasury_rates(**kwargs)
        elif provider == "polygon":
            # Polygon for equity data
            response = await obb.equity.price.historical(**kwargs)
        elif provider in ["fmp", "polygon"]:
            response = await obb.equity.price.historical(**kwargs)
        else:
            # Default to FRED
            response = await obb.economy.fred_series(**kwargs)
            
        return process_response(response)
    except Exception as e:
        # Log the actual error for debugging
        print(f"Error in universal_data for {symbol} from {provider}: {str(e)}")
        return {"error": str(e), "data": []}

# Universal search endpoint - Enhanced for all providers
@app.get("/api/v1/universal/search")
async def universal_search(query: str, provider: Optional[str] = None):
    try:
        all_results = []
        
        if provider:
            # Search specific provider
            if provider == "ecb":
                ecb_response = await ecb_search(query)
                all_results.extend(ecb_response.get("results", []))
            elif provider == "newyorkfed":
                nyf_response = await ny_fed_search(query)
                all_results.extend(nyf_response.get("results", []))
            elif provider == "ofr":
                ofr_response = await ofr_search(query)
                all_results.extend(ofr_response.get("results", []))
            elif provider == "treasury":
                treasury_response = await treasury_search(query)
                all_results.extend(treasury_response.get("results", []))
            else:
                # Default FRED search
                response = await obb.economy.fred_search(query=query, provider="fred")
                if hasattr(response, 'results'):
                    for item in response.results:
                        all_results.append({
                            "series_id": item.get("series_id", ""),
                            "title": item.get("title", ""),
                            "units": item.get("units", ""),
                            "frequency": item.get("frequency", ""),
                            "provider": "fred"
                        })
        else:
            # Search all providers
            # FRED search
            try:
                response = await obb.economy.fred_search(query=query, provider="fred")
                if hasattr(response, 'results'):
                    for item in response.results:
                        all_results.append({
                            "series_id": item.get("series_id", ""),
                            "title": item.get("title", ""),
                            "units": item.get("units", ""),
                            "frequency": item.get("frequency", ""),
                            "provider": "fred"
                        })
            except:
                pass
            
            # ECB search
            try:
                ecb_response = await ecb_search(query)
                all_results.extend(ecb_response.get("results", []))
            except:
                pass
            
            # NY Fed search
            try:
                nyf_response = await ny_fed_search(query)
                all_results.extend(nyf_response.get("results", []))
            except:
                pass
            
            # OFR search
            try:
                ofr_response = await ofr_search(query)
                all_results.extend(ofr_response.get("results", []))
            except:
                pass
            
            # Treasury search
            try:
                treasury_response = await treasury_search(query)
                all_results.extend(treasury_response.get("results", []))
            except:
                pass
        
        # Remove duplicates
        seen = set()
        unique_results = []
        for result in all_results:
            key = f"{result['series_id']}_{result['provider']}"
            if key not in seen:
                seen.add(key)
                unique_results.append(result)
        
        return {"results": unique_results[:100]}
    except Exception as e:
        print(f"Error in universal_search: {str(e)}")
        return {"error": str(e), "results": []}

# Analytics endpoints
@app.get("/api/v1/analytics/trend")
async def trend_analysis(
    symbol: str,
    provider: str = "fred",
    window: int = Query(7, description="Rolling window for calculations")
):
    try:
        # Fetch data
        response = await obb.economy.fred_series(symbol=symbol, provider=provider)
        
        if hasattr(response, 'results'):
            data = response.results
            if isinstance(data, list) and len(data) > 0:
                # Convert to DataFrame
                df = pd.DataFrame(data)
                df['date'] = pd.to_datetime(df['date'])
                df = df.sort_values('date')
                df['value'] = pd.to_numeric(df.get('value', df.get(symbol, 0)), errors='coerce')
                
                # Calculate analytics
                df['ma'] = df['value'].rolling(window=window).mean()
                df['std'] = df['value'].rolling(window=window).std()
                df['roc'] = df['value'].pct_change(periods=window) * 100
                
                # Calculate rolling regression slope
                def calc_slope(x):
                    if len(x) < 2:
                        return np.nan
                    indices = np.arange(len(x))
                    if np.all(np.isnan(x)):
                        return np.nan
                    mask = ~np.isnan(x)
                    if np.sum(mask) < 2:
                        return np.nan
                    slope, _, _, _, _ = stats.linregress(indices[mask], x[mask])
                    return slope
                
                df['slope'] = df['value'].rolling(window=window).apply(calc_slope)
                
                # Prepare response
                results = df.tail(100).to_dict('records')
                
                return {
                    "data": results,
                    "metadata": {
                        "symbol": symbol,
                        "window": window,
                        "latest_value": float(df['value'].iloc[-1]),
                        "latest_ma": float(df['ma'].iloc[-1]) if not np.isnan(df['ma'].iloc[-1]) else None,
                        "latest_roc": float(df['roc'].iloc[-1]) if not np.isnan(df['roc'].iloc[-1]) else None,
                        "latest_slope": float(df['slope'].iloc[-1]) if not np.isnan(df['slope'].iloc[-1]) else None
                    }
                }
        
        return {"data": [], "error": "No data available"}
        
    except Exception as e:
        return {"error": str(e), "data": []}

@app.get("/api/v1/analytics/composite")
async def composite_analysis(
    symbols: List[str] = Query(..., description="List of symbols to analyze"),
    provider: str = "fred",
    formula: Optional[str] = Query(None, description="Formula to apply (e.g., 'spread', 'ratio')")
):
    try:
        all_data = {}
        
        # Fetch data for each symbol
        for symbol in symbols:
            response = await obb.economy.fred_series(symbol=symbol, provider=provider)
            if hasattr(response, 'results'):
                df = pd.DataFrame(response.results)
                df['date'] = pd.to_datetime(df['date'])
                df = df.sort_values('date')
                df['value'] = pd.to_numeric(df.get('value', df.get(symbol, 0)), errors='coerce')
                all_data[symbol] = df.set_index('date')['value']
        
        if len(all_data) > 0:
            # Combine all series
            combined = pd.DataFrame(all_data)
            
            # Apply formula if specified
            if formula == "spread" and len(symbols) == 2:
                combined['spread'] = combined[symbols[0]] - combined[symbols[1]]
            elif formula == "ratio" and len(symbols) == 2:
                combined['ratio'] = combined[symbols[0]] / combined[symbols[1]]
            
            # Calculate changes
            for col in combined.columns:
                combined[f'{col}_pct_change'] = combined[col].pct_change() * 100
                combined[f'{col}_7d_change'] = combined[col].pct_change(periods=7) * 100
            
            # Prepare response
            results = combined.tail(100).reset_index().to_dict('records')
            
            return {
                "data": results,
                "metadata": {
                    "symbols": symbols,
                    "formula": formula,
                    "latest_values": {col: float(combined[col].iloc[-1]) for col in symbols if col in combined.columns and not np.isnan(combined[col].iloc[-1])}
                }
            }
        
        return {"data": [], "error": "No data available"}
        
    except Exception as e:
        return {"error": str(e), "data": []}

@app.get("/api/v1/analytics/liquidity_stress")
async def liquidity_stress():
    try:
        # Fetch VIX data as stress indicator
        response = await obb.economy.fred_series(symbol="VIXCLS", provider="fred")
        
        if hasattr(response, 'results'):
            df = pd.DataFrame(response.results)
            df['date'] = pd.to_datetime(df['date'])
            df = df.sort_values('date')
            df['value'] = pd.to_numeric(df.get('value', df.get('VIXCLS', 0)), errors='coerce')
            
            # Calculate stress levels
            latest_vix = df['value'].iloc[-1]
            ma_20 = df['value'].tail(20).mean()
            ma_60 = df['value'].tail(60).mean()
            
            # Determine stress level
            if latest_vix < 20:
                stress_level = "Low"
            elif latest_vix < 30:
                stress_level = "Moderate"
            elif latest_vix < 40:
                stress_level = "High"
            else:
                stress_level = "Extreme"
            
            return {
                "data": {
                    "current_vix": float(latest_vix),
                    "ma_20": float(ma_20),
                    "ma_60": float(ma_60),
                    "stress_level": stress_level,
                    "timestamp": df['date'].iloc[-1].isoformat()
                },
                "historical": df.tail(30).to_dict('records')
            }
        
        return {"data": {}, "error": "No data available"}
        
    except Exception as e:
        return {"error": str(e), "data": {}}

# NEW ENDPOINTS FOR ECB, NY FED, OFR, AND TREASURY DATA

@app.get("/api/v1/economy/ecb_search")
async def ecb_search(query: str):
    """Search ECB data series."""
    try:
        # First, try searching FRED for ECB-related series
        results = []
        
        # Search FRED for ECB data
        response = await obb.economy.fred_search(
            query=f"ECB {query}",
            provider="fred"
        )
        
        if response and hasattr(response, 'results'):
            for item in response.results:
                series_id = str(item.get('series_id', '')).upper()
                title = str(item.get('title', '')).upper()
                if any(prefix in series_id or prefix in title 
                      for prefix in ['ECB', 'EUR', 'EU', 'EUROPEAN']):
                    results.append({
                        "series_id": item.get("series_id", ""),
                        "title": item.get("title", ""),
                        "units": item.get("units", ""),
                        "frequency": item.get("frequency", ""),
                        "provider": "ecb"
                    })
        
        # Add common ECB indicators if they match the query
        ecb_common_series = {
            "CISS": "Composite Indicator of Systemic Stress",
            "ECBDFR": "ECB Deposit Facility Rate",
            "ECBMLFR": "ECB Marginal Lending Facility Rate", 
            "ECBMRRFR": "ECB Main Refinancing Operations Rate",
            "EURONTD": "Euro Area Overnight Deposits",
            "EONIA": "Euro Overnight Index Average",
            "EURIBOR3M": "3-Month EURIBOR",
            "EURR002W": "ECB Euro Short-Term Rate",
            "CISS.D.CN.Z0Z.4F.EC.SS_CIN.IDX": "CISS - China Systemic Stress"
        }
        
        query_lower = query.lower()
        for series_id, description in ecb_common_series.items():
            if query_lower in series_id.lower() or query_lower in description.lower():
                results.append({
                    "series_id": series_id,
                    "title": description,
                    "units": "Index" if "CISS" in series_id else "Percent",
                    "frequency": "D",
                    "provider": "ecb"
                })
        
        return {"results": results[:50]}
    except Exception as e:
        return {"error": str(e), "results": []}

@app.get("/api/v1/economy/ny_fed_search")
async def ny_fed_search(query: str):
    """Search New York Fed data series."""
    try:
        results = []
        
        # Common NY Fed series
        ny_fed_series = {
            "SOFR": "Secured Overnight Financing Rate",
            "EFFR": "Effective Federal Funds Rate",
            "OBFR": "Overnight Bank Funding Rate",
            "TGCR": "Tri-Party General Collateral Rate",
            "BGCR": "Broad General Collateral Rate",
            "SOFR30DAVG": "30-Day Average SOFR",
            "SOFR90DAVG": "90-Day Average SOFR",
            "SOFR180DAVG": "180-Day Average SOFR",
            "IORB": "Interest on Reserve Balances",
            "RRPONTSYD": "Overnight Reverse Repurchase Agreements",
            "RESBALNS": "Reserve Balances at Federal Reserve Banks",
            "WRESBAL": "Reserve Balances Wednesday Level",
            "RESPPLLOPNWW": "Central Bank Liquidity Swaps",
            "H41RESPPLLBNWW": "Central Bank Liquidity Swap Operations"
        }
        
        query_lower = query.lower()
        
        # Add matching NY Fed series
        for series_id, description in ny_fed_series.items():
            if query_lower in series_id.lower() or query_lower in description.lower():
                results.append({
                    "series_id": series_id,
                    "title": description,
                    "units": "Percent" if "Rate" in description else "Billions of Dollars",
                    "frequency": "D",
                    "provider": "newyorkfed"
                })
        
        # Also search FRED for NY Fed data
        response = await obb.economy.fred_search(
            query=query,
            provider="fred"
        )
        
        if response and hasattr(response, 'results'):
            ny_fed_keywords = ["SOFR", "EFFR", "OBFR", "TGCR", "BGCR", "RRP", "RESERVE", "IORB", "REPO", "FED"]
            
            for item in response.results:
                series_id = str(item.get('series_id', '')).upper()
                title = str(item.get('title', '')).upper()
                
                if any(keyword in series_id or keyword in title for keyword in ny_fed_keywords):
                    result = {
                        "series_id": item.get("series_id", ""),
                        "title": item.get("title", ""),
                        "units": item.get("units", ""),
                        "frequency": item.get("frequency", ""),
                        "provider": "newyorkfed"
                    }
                    
                    # Avoid duplicates
                    if not any(r['series_id'] == result['series_id'] for r in results):
                        results.append(result)
                        
        return {"results": results[:50]}
    except Exception as e:
        return {"error": str(e), "results": []}

@app.get("/api/v1/economy/ofr_search")
async def ofr_search(query: str):
    """Search Office of Financial Research data series."""
    try:
        results = []
        
        # OFR specific series from their datasets
        ofr_series = {
            "NYPD-PD_AFtR_T-A": "NY Prime Dealers - After Rate Total Amount",
            "STFM": "Short-term Funding Monitor",
            "BANKSTRESS": "Bank Systemic Risk Monitor",
            "FINLEVERAGE": "Financial Sector Leverage",
            "STLFSI3": "St. Louis Fed Financial Stress Index",
            "NFCI": "National Financial Conditions Index",
            "ANFCI": "Adjusted National Financial Conditions Index",
            "NFCILEVERAGE": "NFCI Leverage Subindex",
            "NFCIRISK": "NFCI Risk Subindex",
            "NFCICREDIT": "NFCI Credit Subindex",
            "TEDRATE": "TED Spread",
            "T10Y3M": "10-Year Treasury Constant Maturity Minus 3-Month Treasury",
            "BAMLH0A0HYM2": "ICE BofA US High Yield Index Option-Adjusted Spread",
            "DEXCHUS": "China / U.S. Foreign Exchange Rate"
        }
        
        query_lower = query.lower()
        
        # Add matching OFR series
        for series_id, description in ofr_series.items():
            if query_lower in series_id.lower() or query_lower in description.lower():
                results.append({
                    "series_id": series_id,
                    "title": description,
                    "units": "Index" if "Index" in description else "Percent",
                    "frequency": "D",
                    "provider": "ofr"
                })
        
        # Search FRED for financial stress indicators
        response = await obb.economy.fred_search(
            query=f"{query} stress financial systemic",
            provider="fred"
        )
        
        if response and hasattr(response, 'results'):
            ofr_keywords = ['OFR', 'STRESS', 'SPREAD', 'FINANCIAL', 'SYSTEMIC', 'LEVERAGE', 'NFCI', 'TED']
            
            for item in response.results:
                title = str(item.get('title', '')).upper()
                series_id = str(item.get('series_id', '')).upper()
                
                if any(term in title or term in series_id for term in ofr_keywords):
                    result = {
                        "series_id": item.get("series_id", ""),
                        "title": item.get("title", ""),
                        "units": item.get("units", ""),
                        "frequency": item.get("frequency", ""),
                        "provider": "ofr"
                    }
                    
                    # Avoid duplicates
                    if not any(r['series_id'] == result['series_id'] for r in results):
                        results.append(result)
                        
        return {"results": results[:50]}
    except Exception as e:
        return {"error": str(e), "results": []}

@app.get("/api/v1/economy/treasury_search")
async def treasury_search(query: str):
    """Search Treasury auction data."""
    try:
        results = []
        
        # Treasury auction series
        treasury_series = {
            "DGS1MO": "Market Yield on U.S. Treasury Securities at 1-Month Constant Maturity",
            "DGS3MO": "Market Yield on U.S. Treasury Securities at 3-Month Constant Maturity",
            "DGS6MO": "Market Yield on U.S. Treasury Securities at 6-Month Constant Maturity",
            "DGS1": "Market Yield on U.S. Treasury Securities at 1-Year Constant Maturity",
            "DGS2": "Market Yield on U.S. Treasury Securities at 2-Year Constant Maturity",
            "DGS3": "Market Yield on U.S. Treasury Securities at 3-Year Constant Maturity",
            "DGS5": "Market Yield on U.S. Treasury Securities at 5-Year Constant Maturity",
            "DGS7": "Market Yield on U.S. Treasury Securities at 7-Year Constant Maturity",
            "DGS10": "Market Yield on U.S. Treasury Securities at 10-Year Constant Maturity",
            "DGS20": "Market Yield on U.S. Treasury Securities at 20-Year Constant Maturity",
            "DGS30": "Market Yield on U.S. Treasury Securities at 30-Year Constant Maturity",
            "DFII5": "Market Yield on U.S. Treasury Inflation-Indexed Securities at 5-Year Constant Maturity",
            "DFII10": "Market Yield on U.S. Treasury Inflation-Indexed Securities at 10-Year Constant Maturity",
            "DFII20": "Market Yield on U.S. Treasury Inflation-Indexed Securities at 20-Year Constant Maturity",
            "DFII30": "Market Yield on U.S. Treasury Inflation-Indexed Securities at 30-Year Constant Maturity",
            "T5YIE": "5-Year Breakeven Inflation Rate",
            "T10YIE": "10-Year Breakeven Inflation Rate",
            "TB3MS": "3-Month Treasury Bill Secondary Market Rate",
            "TB6MS": "6-Month Treasury Bill Secondary Market Rate",
            "TB1YR": "1-Year Treasury Bill Secondary Market Rate"
        }
        
        query_lower = query.lower()
        
        # Add matching Treasury series
        for series_id, description in treasury_series.items():
            if query_lower in series_id.lower() or query_lower in description.lower():
                results.append({
                    "series_id": series_id,
                    "title": description,
                    "units": "Percent",
                    "frequency": "D",
                    "provider": "treasury"
                })
        
        # Search FRED for treasury data
        treasury_terms = ["BILL", "NOTE", "BOND", "TREASURY", "AUCTION", "DGS", "TIPS", "YIELD", "T-BILL"]
        
        response = await obb.economy.fred_search(
            query=f"treasury {query}",
            provider="fred"
        )
        
        if response and hasattr(response, 'results'):
            for item in response.results:
                series_id = str(item.get('series_id', '')).upper()
                title = str(item.get('title', '')).upper()
                
                if any(term in series_id or term in title for term in treasury_terms):
                    result = {
                        "series_id": item.get("series_id", ""),
                        "title": item.get("title", ""),
                        "units": item.get("units", ""),
                        "frequency": item.get("frequency", ""),
                        "provider": "treasury"
                    }
                    
                    # Avoid duplicates
                    if not any(r['series_id'] == result['series_id'] for r in results):
                        results.append(result)
                        
        return {"results": results[:50]}
    except Exception as e:
        return {"error": str(e), "results": []}

# Data retrieval endpoints

@app.get("/api/v1/economy/ecb_series")
async def ecb_series(symbol: str, provider: str = "ecb", limit: Optional[int] = None):
    """Get ECB data series."""
    try:
        # Use ECB provider directly
        kwargs = {"symbol": symbol, "provider": "ecb"}
        if limit:
            kwargs["limit"] = limit
        
        # Try ECB-specific endpoint first
        try:
            response = await obb.economy.european_central_bank(symbol=symbol)
            return process_response(response)
        except:
            # Fallback to generic economy data with ECB provider
            response = await obb.economy.fred_series(**kwargs)
            return process_response(response)
    except Exception as e:
        return {"error": str(e), "data": []}

@app.get("/api/v1/economy/ny_fed_series")
async def ny_fed_series(symbol: str, provider: str = "newyorkfed", limit: Optional[int] = None):
    """Get New York Fed data series."""
    try:
        # Use NY Fed provider directly
        kwargs = {"symbol": symbol, "provider": "newyorkfed"}
        if limit:
            kwargs["limit"] = limit
        
        # Try NY Fed specific endpoints
        try:
            # For SOFR and related rates
            if symbol in ["SOFR", "EFFR", "OBFR", "TGCR", "BGCR"]:
                response = await obb.fixedincome.rate(symbol=symbol, provider="newyorkfed")
                return process_response(response)
            else:
                # For other NY Fed data
                response = await obb.economy.fred_series(symbol=symbol, provider="newyorkfed")
                return process_response(response)
        except:
            # Fallback to FRED if NY Fed provider fails
            response = await obb.economy.fred_series(symbol=symbol, provider="fred")
            return process_response(response)
    except Exception as e:
        return {"error": str(e), "data": []}

@app.get("/api/v1/economy/ofr_series")
async def ofr_series(symbol: str, provider: str = "ofr", limit: Optional[int] = None):
    """Get OFR data series."""
    try:
        # Use OFR provider directly
        kwargs = {"symbol": symbol, "provider": "ofr"}
        if limit:
            kwargs["limit"] = limit
        
        # Try OFR specific endpoint
        try:
            response = await obb.economy.fred_series(**kwargs)
            return process_response(response)
        except:
            # If OFR provider fails, the symbol might be in FRED
            response = await obb.economy.fred_series(symbol=symbol, provider="fred")
            return process_response(response)
    except Exception as e:
        return {"error": str(e), "data": []}

@app.get("/api/v1/economy/treasury_auctions")
async def treasury_auctions(
    cusip: Optional[str] = None,
    symbol: Optional[str] = None,
    provider: str = "treasury",
    limit: Optional[int] = None
):
    """Get Treasury auction data."""
    try:
        series_id = cusip or symbol
        if not series_id:
            return {"error": "Either cusip or symbol required", "data": []}
        
        # Try treasury-specific endpoints
        try:
            # For treasury yields
            if series_id.startswith("DGS") or series_id.startswith("TB"):
                response = await obb.fixedincome.government.treasury_rates(provider="treasury")
                return process_response(response)
            else:
                # For treasury auction data
                response = await obb.fixedincome.government.treasury_auctions(provider="treasury")
                return process_response(response)
        except:
            # Fallback to FRED for treasury data
            kwargs = {"symbol": series_id, "provider": "fred"}
            if limit:
                kwargs["limit"] = limit
            response = await obb.economy.fred_series(**kwargs)
            return process_response(response)
    except Exception as e:
        return {"error": str(e), "data": []}

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)